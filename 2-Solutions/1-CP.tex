\section{Constraint Programming}
As said, \acrf{MAPF} problem is NP-hard and it has been proven to reduce to
\acrf{SAT}. For this reason, the usage of constraint programming has been
deeply explored using different techniques to solve the constraints:
\begin{itemize}
  \item \acrf{CSP}: 
  \item \acrf{SAT}:
  \item \acrf{MIP}:
\end{itemize}

The first step was to take the model proposed in~\cite{picat1} and implement it
using CPLEX \acrf{OPL}~\cite{OPL}. The goal of moving the model to another
programming language was to exploit the straightforward similarity between the
problem and \acrs{MIP} and also to exploit the optimal performance of IBM's 
solver. \newline
There many differences between the two programming language and in the way they
can be used to solve the problem. For example, CPLEX works by either
minimizing or maximizing and objective function, while Picat is used to solve
over a given decision variable. Another striking difference is the fact that
Picat can use different solvers for the constraint: indeed, it is designed to
generally define the constraints and then solve them either with \acrs{SAT},
\acrs{MIP} or \acrs{CP}. \newline 
The objective function that was initially sought was to minimize the sum of the
movements of all the agents in the graph, i.e., minimizing the \textit{sum of 
costs}. The constrained defined in~\cite{picat1} are being reused:
\begin{itemize}
  \item Each agent $a$ cannot be on more than one node at each time:
    \begin{equation}
      \forall s \in \mathcal{S},~\Sum_{n \in \mathcal{N}} X[s][n][a]=1
      \label{eq:picat1_one_agent_one_node}
    \end{equation}
  \item Each node $n$ cannot be occupied by more than one agent at each time:
    \begin{equation}
      \forall s \in \mathcal{S},~\Sum{a \in \mathcal{A}} X[s][n][a]\leq 1
      \label{eq:picat1_one_node_one_agent}
    \end{equation}
  \item If an agent $a$ occupies a node $n$ at time $s$, it will occupy a
    neighboring node $m$ at time $s+1$:
    \begin{equation}
      X[s][n][a]=1 \quad \Rightarrow \Sum_{m\in \neigh{n}} X[s+1][m][a]=1
      \label{eq:picat1_move_to_neigh}
    \end{equation}
\end{itemize}
There are some problems with using these constraints as they are in CPLEX:
\begin{itemize}
  \item The above constraints do not bind the initial and final position of the
    agents. Indeed, in the code proposed in~\cite{picat1}, the assignment of
    the initial and final position for each agent is done via preprocessing,
    but this was not possible with \OPL. Two constraints where then introduced:
    \begin{equation}
      \forall a \in \mathcal{A},~X[t_0][S_a][a] = 1
      \label{eq:cplex_init_pos}
    \end{equation}
    \begin{equation}
      \forall a \in \mathcal{A},~X[t_f][E_a][a] = 1
      \label{eq:cplex_final_pos}
    \end{equation}
  \item Although the swap conflict was not taken into consideration due to the
    increased computational cost as stated in~\cite{picat1}, in this work, it 
    is important to avoid this type of conflict. A first constraint to avoid a
    swap conflict is the following:
    \begin{equation}
      \begin{split}
      \forall s \in\mathcal{S}/\{t_f\},~\forall a_i \in\mathcal{A},~\forall 
      a_j\in \mathcal{A}/\{a_i\},~\forall n_i \in \mathcal{N},~\forall n_j \in 
      \mathcal{N}/\{n_i\},\\
      X[s][n_i][a_i] \wedge X[s][n_j][a_j] \Rightarrow
      X[s+1][n_j][a_i]\wedge X[s+1][n_i][a_j]
      \end{split}
      \label{eq:cplex_no_swaps}
    \end{equation}
    This though increases a lot the time required to find a solution. For
    example, considering the graph shown in Figure~\ref{fig:CPLEX_bad_swaps},
    the time required to solve the \MAPF problem with two agents staring at
    nodes \texttt{initPos=[]}  
    %TODO figure
    %\begin{figure}[htpb]
    %  \centering
    %  \includegraphics[width=0.8\textwidth]{CPLEX_bad_swaps}
    %  \caption{Example of possible graph to be solved.}
    %  \label{fig:CPLEX_bad_swaps}
    %\end{figure}
    
\end{itemize}
